#!/usr/bin/env python3
import argparse
import base64
import json
import gzip
import hashlib
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

import sys
sys.stdout.reconfigure(encoding='utf-8')

# --- AES key from the binary (32 bytes = AES-256) -------------------------

AES_KEY = b"Nu det jul og tr\xe6et t\xe6ndes p\xe5 ny"


# --- XOR layer: reimplementation of shared.xorEncrypt --------------------

def xor_layer(data: bytes, timestamp: int) -> bytes:
    """
    Reproduce github.com/S4rp3d0n/minos-c2/shared.xorEncrypt

    Go logic (from the decompile):
      - Take the 8-byte representation of `timestamp`
      - SHA-256 over those 8 bytes --> 32-byte digest (local_30)
      - For each byte i of the slice:
            out[i] = in[i] ^ digest[i % 32]
    """

    # In the Go binary they store the timestamp in an 8-byte variable and hash that.
    # On amd64 that is little-endian, so we mirror that here.
    t = timestamp & ((1 << 64) - 1)
    ts_bytes = t.to_bytes(8, byteorder="little", signed=False)

    digest = hashlib.sha256(ts_bytes).digest()  # 32 bytes

    out = bytearray(len(data))
    for i, b in enumerate(data):
        out[i] = b ^ digest[i % 32]
    return bytes(out)


# --- Decompression: mirrors shared.compressData (gzip) --------------------

def decompress_layer(data: bytes) -> bytes:
    """
    shared.compressData uses compress/gzip with a bytes.Buffer,
    so we undo it with gzip.decompress.
    """
    return gzip.decompress(data)


# --- Core decryption pipeline ---------------------------------------------

def decrypt_payload(body_b64: str, timestamp: int) -> bytes:
    """
    body_b64 : base64 HTTP POST body from the malware
    timestamp: integer from X-Timestamp header (same value passed into EncryptMultiLayer)

    Pipeline (reverse of BuildEncryptedRequest + EncryptMultiLayer):
      1. base64 decode
      2. split nonce (12 bytes) and ciphertext+tag
      3. AES-GCM decrypt
      4. xor_layer (undo xorEncrypt)
      5. gzip decompress
    """
    # 1) Base64 decode
    raw = base64.b64decode(body_b64)

    if len(raw) < 12 + 16:
        raise ValueError(f"Payload too short ({len(raw)} bytes) to contain nonce + GCM data")

    # 2) Split: first 12 bytes are GCM nonce, rest is ciphertext+tag
    nonce = raw[:12]
    ct_and_tag = raw[12:]

    # 3) AES-GCM decrypt (no AAD in the decompiled code)
    aesgcm = AESGCM(AES_KEY)
    xor_compressed = aesgcm.decrypt(nonce, ct_and_tag, None)

    # 4) Undo XOR layer using same timestamp as X-Timestamp
    compressed = xor_layer(xor_compressed, timestamp)

    # 5) GZIP decompress to get the original JSON bytes
    plaintext = decompress_layer(compressed)

    return plaintext


# --- Command-line interface -----------------------------------------------

def main():
    parser = argparse.ArgumentParser(
        description="Decrypt minos-c2 / Skuld-style C2 payload from captured HTTP traffic."
    )
    parser.add_argument(
        "--body-b64",
        help="Base64-encoded HTTP POST body (from the PCAP).",
    )
    parser.add_argument(
        "--body-file",
        help="File containing the base64 body (one line or whole file).",
    )
    parser.add_argument(
        "--timestamp",
        required=True,
        type=int,
        help="X-Timestamp header value as integer.",
    )
    parser.add_argument(
        "--json",
        action="store_true",
        help="Parse decrypted output as JSON and pretty-print.",
    )
    args = parser.parse_args()

    if not args.body_b64 and not args.body_file:
        parser.error("Provide either --body-b64 or --body-file")

    if args.body_file:
        with open(args.body_file, "r", encoding="utf-8") as f:
            body_b64 = f.read().strip()
    else:
        body_b64 = args.body_b64.strip()

    plaintext = decrypt_payload(body_b64, args.timestamp)

    if args.json:
        try:
            obj = json.loads(plaintext.decode("utf-8", errors="replace"))
            print(json.dumps(obj, indent=2, ensure_ascii=False))
        except Exception as e:
            print(f"[!] Failed to parse JSON: {e}")
            print("Raw plaintext:")
            print(plaintext.decode("utf-8", errors="replace"))
    else:
        print(plaintext.decode("utf-8", errors="replace"))


if __name__ == "__main__":
    main()
